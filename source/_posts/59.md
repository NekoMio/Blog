---
title: "[BZOJ 4832] [Lydsy2017年4月月赛]抵制克苏恩"
date: 2017-8-3 8:14:26
categories: 题解
tags:
    - 概率DP
toc: true
---

### Description
小Q同学现在沉迷炉石传说不能自拔。他发现一张名为克苏恩的牌很不公平。如果你不玩炉石传说，不必担心，小Q
同学会告诉你所有相关的细节。炉石传说是这样的一个游戏，每个玩家拥有一个 30 点血量的英雄，并且可以用牌
召唤至多 7 个随从帮助玩家攻击对手，其中每个随从也拥有自己的血量和攻击力。小Q同学有很多次游戏失败都是
因为对手使用了克苏恩这张牌，所以他想找到一些方法来抵御克苏恩。他去求助职业炉石传说玩家椎名真白，真白
<!--more-->
告诉他使用奴隶主这张牌就可以啦。如果你不明白我上面在说什么，不必担心，小Q同学会告诉你他想让你做什么
。现在小Q同学会给出克苏恩的攻击力是 K ，表示克苏恩会攻击 K 次，每次会从对方场上的英雄和随从中随机选
择一个并对其产生 1 点伤害。现在对方有一名克苏恩，你有一些奴隶主作为随从，每名奴隶主的血量是给定的。
如果克苏恩攻击了你的一名奴隶主，那么这名奴隶主的血量会减少 1 点，当其血量小于等于 0 时会死亡，如果受
到攻击后不死亡，并且你的随从数量没有达到 7 ，这名奴隶主会召唤一个拥有 3 点血量的新奴隶主作为你的随从
；如果克苏恩攻击了你的英雄，你的英雄会记录受到 1 点伤害。你应该注意到了，每当克苏恩进行一次攻击，你
场上的随从可能发生很大的变化。小Q同学为你假设了克苏恩的攻击力，你场上分别有 1 点、 2 点、 3 点血量的
奴隶主数量，你可以计算出你的英雄受到的总伤害的期望值是多少吗？
 
 
 
### Input
输入包含多局游戏。
第一行包含一个整数 T (T<100) ，表示游戏的局数。
每局游戏仅占一行，包含四个非负整数 K, A, B 和 C ，表示克苏恩的攻击力是 K ，你有 A 个 1 点血量的奴隶
主， B 个 2 点血量的奴隶主， C 个 3 点血量的奴隶主。
保证 K 是小于 50 的正数， A+B+C 不超过 7 。
 
 
### Output
对于每局游戏，输出一个数字表示总伤害的期望值，保留两位小数。

 
### Sample Input
>1  
1 1 1 1  

### Sample Output
>0.25

## 题解
简单的基础概率DP

```c++
#include <cstdio>
#include <cstring>
using namespace std;
double f[55][8][8][8];
int main(int argc, char const *argv[])
{
    int T, a, b, c, k;
    scanf("%d", &T);
    while (T--)
    {
        scanf("%d%d%d%d", &k, &a, &b, &c);
        memset(f, 0, sizeof(f));
        f[1][a][b][c] = 1;
        double ans = 0;
        for (int i = 1; i <= k; i++)
        {
            for (int j = 0; j <= 7; j++)
                for (int l = 0; l <= 7; l++)
                    for (int m = 0; m <= 7; m++)
                    {
                        if (l + j + m <= 7)
                        {
                            if (j > 0)
                                f[i + 1][j - 1][l][m] += f[i][j][l][m] * j * 1.0 / (l + j + m + 1);
                            if (l > 0)
                            {
                                if (l + j + m <= 6)
                                    f[i + 1][j + 1][l - 1][m + 1] += f[i][j][l][m] * l * 1.0 / (l + j + m + 1);
                                else
                                    f[i + 1][j + 1][l - 1][m] += f[i][j][l][m] * l * 1.0 / (l + j + m + 1);
                            }
                            if (m > 0)
                            {
                                if (l + j + m <= 6)
                                    f[i + 1][j][l + 1][m] += f[i][j][l][m] * m * 1.0 / (l + j + m + 1);
                                else
                                    f[i + 1][j][l + 1][m - 1] += f[i][j][l][m] * m * 1.0 / (l + j + m + 1);
                            }
                            f[i + 1][j][l][m] += f[i][j][l][m] * 1.0 / (l + j + m + 1);
                            ans += f[i][j][l][m] * 1.0 / (l + j + m + 1);
                        }
                    }
        }
        printf("%.2lf\n", ans);
    }
    //while (1)
        ;
    return 0;
}

```